#!/usr/bin/env python3
"""
menuscript – unified CLI entrypoint
- Official entrypoint is the `menuscript` console script (not `python -m ...`)
- Clean, predictable routing:
    menuscript                      -> interactive TUI
    menuscript --help               -> CLI help
    menuscript --version            -> show version + branding
    menuscript migrate              -> DB migration (manual)
    menuscript config plugins ...   -> manage plugin enable/disable/reset
    menuscript plugins              -> alias of: config plugins list
    menuscript plugin on/off/reset  -> aliases for enable/disable/reset
    menuscript dev repair           -> developer smart repair tool
"""

from __future__ import annotations
import sys
import json
import difflib

# TUI launcher
from .ui import run_menu_loop

# DB migration helpers (keep minimal surface)
from .storage.db import init_db, import_json_history_to_db
from .utils import HISTORY_FILE

# Plugin loader + config helpers for the `config plugins` command
from .engine.loader import discover_plugins
from .config import (
    list_plugins_config,
    enable_plugin,
    disable_plugin,
    reset_plugins,
)

# Colors (minimal, readable)
CSI = "\033["
RESET = CSI + "0m"
BOLD = CSI + "1m"
GREEN = CSI + "32m"
RED = CSI + "31m"
CYAN = CSI + "36m"

# ---- Branding / Version -----------------------------------------------------


def _print_version() -> int:
    """
    Print version and branding for --version.
    NOTE: Keep this string in sync with setup.py version during releases.
    """
    # If you prefer to import from a single version source later, you can.
    version = "v0.6.0"
    print(f"menuscript {version}")
    print("by y0d8 & CyberSoul SecurITy ($0u! H@cK3R$)")
    return 0


def _print_help() -> int:
    """
    Professional H2-style help: concise, with command summary.
    """
    print(
        f"""{BOLD}Usage:{RESET}
  menuscript                          Launch interactive menu (TUI)
  menuscript --help                   Show this help
  menuscript --version                Show version and branding

{BOLD}Admin & Migration:{RESET}
  menuscript migrate                  Import JSON history into SQLite (one-time)

{BOLD}Plugin Management:{RESET}
  menuscript config plugins list
  menuscript config plugins enable <name>
  menuscript config plugins disable <name>
  menuscript config plugins reset

{BOLD}Short Aliases:{RESET}
  menuscript plugins                  (same as: config plugins list)
  menuscript plugin on  <name>        (enable)
  menuscript plugin off <name>        (disable)
  menuscript plugin reset             (reset)

{BOLD}Developer Tools:{RESET}
  menuscript dev repair               Smart reinstall + cache cleanup + checks

{BOLD}Tips:{RESET}
  • Plugin names are case-insensitive.
  • Edit config at ~/.menuscript/config.json (auto-repairs if corrupted).
"""
    )
    return 0


# ---- Small utilities --------------------------------------------------------


def _suggest(word: str, options: list[str]) -> str | None:
    """
    Suggest a close command if user mistypes (e.g., 'repaor' -> 'repair').
    """
    matches = difflib.get_close_matches(word, options, n=1, cutoff=0.72)
    return matches[0] if matches else None


# ---- Commands: migrate / config plugins / dev -------------------------------


def _cmd_migrate() -> int:
    """
    Manual DB migration entrypoint:
    - Initializes DB
    - Imports legacy JSON history (if present)
    - Removes legacy JSON afterwards
    """
    init_db()
    imported = import_json_history_to_db()
    # remove legacy JSON (best-effort; safe to skip if already gone)
    try:
        import pathlib

        pathlib.Path(HISTORY_FILE).unlink(missing_ok=True)
    except Exception:
        pass
    print(GREEN + f"Migration complete. Imported entries: {imported}" + RESET)
    return 0


def _print_plugins_list() -> None:
    """
    Shared pretty-printer for 'config plugins list' and 'plugins' alias.
    """
    discovered = sorted(discover_plugins().keys())
    enabled, disabled = list_plugins_config()

    print(BOLD + "Enabled plugins:" + RESET)
    if enabled:
        for n in enabled:
            print("  - " + GREEN + n + RESET)
    else:
        print("  (none explicitly enabled — all discovered are active unless disabled)")

    print(BOLD + "\nDisabled plugins:" + RESET)
    if disabled:
        for n in disabled:
            print("  - " + RED + n + RESET)
    else:
        print("  (none)")

    print(BOLD + "\nDiscovered plugins:" + RESET)
    for n in discovered:
        print("  - " + n)


def _cmd_config_plugins(argv: list[str]) -> int:
    """
    Implementation for:
      menuscript config plugins [list|enable|disable|reset]
    """
    sub = (argv[0].lower() if argv else "list")
    discovered_set = set(discover_plugins().keys())

    # Accept friendly aliases
    if sub in ("list", "ls"):
        _print_plugins_list()
        return 0

    if sub in ("enable", "on", "+"):
        if len(argv) < 2:
            print("Usage: menuscript config plugins enable <name>")
            return 2
        name = argv[1].lower()
        if name not in discovered_set:
            print(RED + f"Plugin '{name}' not found among discovered." + RESET)
            if suggestion := _suggest(name, list(discovered_set)):
                print(CYAN + f"Did you mean: {suggestion} ?" + RESET)
            return 1
        enable_plugin(name)
        print(GREEN + f"Enabled: {name}" + RESET)
        return 0

    if sub in ("disable", "off", "-"):
        if len(argv) < 2:
            print("Usage: menuscript config plugins disable <name>")
            return 2
        name = argv[1].lower()
        if name not in discovered_set:
            print(RED + f"Plugin '{name}' not found among discovered." + RESET)
            if suggestion := _suggest(name, list(discovered_set)):
                print(CYAN + f"Did you mean: {suggestion} ?" + RESET)
            return 1
        disable_plugin(name)
        print(RED + f"Disabled: {name}" + RESET)
        return 0

    if sub == "reset":
        reset_plugins()
        print(CYAN + "Plugins config reset (auto-discover all; none explicitly enabled/disabled)." + RESET)
        return 0

    if sub in ("help", "-h", "--help"):
        print(
            """Usage:
  menuscript config plugins list
  menuscript config plugins enable <name>
  menuscript config plugins disable <name>
  menuscript config plugins reset
"""
        )
        return 0

    # Unknown subcommand with suggestion
    print(RED + f"Unknown subcommand: {sub}" + RESET)
    if suggestion := _suggest(sub, ["list", "enable", "disable", "reset"]):
        print(CYAN + f"Did you mean: {suggestion} ?" + RESET)
    return 2


def _cmd_jobs(argv):
    """
    jobs subcommand:
      menuscript jobs enqueue <tool> <target> --args "<arg1 arg2 ...>" --label "optional"
      menuscript jobs list
      menuscript jobs status <id>
      menuscript jobs tail <id>
      menuscript jobs worker start   # start worker in this process (daemonized)
    """
    if not argv:
        print("Usage: menuscript jobs [enqueue|list|status|tail|worker]")
        return 2
    sub = argv[0].lower()
    if sub == "enqueue":
        # simple parser: expect tool target then optional --args "<...>" --label "..."
        if len(argv) < 3:
            print('Usage: menuscript jobs enqueue <tool> <target> --args "<arg1 arg2>" --label "<optional>"')
            return 2
        tool = argv[1].lower()
        target = argv[2]
        # parse optional flags
        args = []
        label = ""
        i = 3
        while i < len(argv):
            a = argv[i]
            if a == "--args" and i+1 < len(argv):
                try:
                    # split the string into args (simple split)
                    args = argv[i+1].split()
                except Exception:
                    args = []
                i += 2
                continue
            if a == "--label" and i+1 < len(argv):
                label = argv[i+1]
                i += 2
                continue
            i += 1
        job_id = enqueue_job(tool, target, args, label)
        print(f"Enqueued job id: {job_id} (tool={tool} target={target})")
        return 0
    if sub == "list":
        jobs = list_jobs(limit=200)
        if not jobs:
            print("No jobs.")
            return 0
        for j in jobs:
            print(f"{j['id']}: {j['tool']} {j['target']} status={j['status']} created={j['created_at']} result_scan_id={j.get('result_scan_id')}")
        return 0
    if sub in ("status","show"):
        if len(argv) < 2:
            print("Usage: menuscript jobs status <id>")
            return 2
        try:
            jid = int(argv[1])
        except Exception:
            print("Invalid job id.")
            return 2
        j = get_job(jid)
        if not j:
            print("Job not found.")
            return 1
        print(json.dumps(j, indent=2))
        return 0
    if sub == "tail":
        # attempt to get scan id and then try to fetch log via storage.db.get_scan
        if len(argv) < 2:
            print("Usage: menuscript jobs tail <id>")
            return 2
        try:
            jid = int(argv[1])
        except Exception:
            print("Invalid job id.")
            return 2
        j = get_job(jid)
        if not j:
            print("Job not found.")
            return 1
        scan_id = j.get("result_scan_id")
        if not scan_id:
            print("Job has no scan result yet.")
            return 1
        # try to import storage.get_scan
        try:
            from .storage.db import get_scan
            rec = get_scan(scan_id)
            if rec and rec.get("log"):
                print(f"--- tail of log ({rec.get('log')}) ---")
                try:
                    with open(rec.get('log'),'r', encoding='utf-8', errors='ignore') as fh:
                        print(''.join(fh.readlines()[-200:]))
                except Exception as e:
                    print("Could not read log file:", e)
            else:
                print("No log path recorded for scan.")
        except Exception:
            print("Cannot tail: storage.get_scan not available in this environment.")
        return 0
    if sub == "worker":
        # e.g., menuscript jobs worker start
        if len(argv) < 2:
            print("Usage: menuscript jobs worker start")
            return 2
        if argv[1] == "start":
            start_worker(detach=True)
            print("Started background worker in this process (daemon). It will process queued jobs.")
            return 0
        print("Unknown worker subcommand.")
        return 2
    print("Unknown jobs subcommand. Try: enqueue|list|status|tail|worker")
    return 2

def _cmd_dev(argv: list[str]) -> int:
    """
    Implementation for:
      menuscript dev repair
    """
    if not argv or argv[0] in ("-h", "--help", "help"):
        print("Usage: menuscript dev repair\n\nRuns a smart reinstall + cache cleanup + version/path checks.")
        return 0

    sub = argv[0].lower()
    if sub == "repair":
        try:
            from .devtools import dev_repair
        except Exception as e:
            print(RED + f"Developer tool not available: {e}" + RESET)
            return 1
        return dev_repair()

    print(RED + f"Unknown dev subcommand: {sub}" + RESET)
    if suggestion := _suggest(sub, ["repair"]):
        print(CYAN + f"Did you mean: {suggestion} ?" + RESET)
    return 2


# ---- CLI Router -------------------------------------------------------------


def main() -> int:
    """
    CLI router. Only falls back to TUI when no command is provided.
    """
    argv = sys.argv[1:]

    # Global flags first
    if not argv:
        # No args -> TUI
        try:
            run_menu_loop()
        except KeyboardInterrupt:
            print("\nInterrupted. Bye.")
            return 130
        return 0

    if argv[0] in ("-h", "--help"):
        return _print_help()

    if argv[0] in ("-v", "--version"):
        return _print_version()

    # Admin command
    if argv[0].lower() == "migrate":
        return _cmd_migrate()

    # Config command (namespaced)
    if argv[0].lower() == "config":
        if len(argv) >= 2 and argv[1].lower() == "plugins":
            return _cmd_config_plugins(argv[2:])
        print("Usage: menuscript config plugins [list|enable|disable|reset]")
        return 2

    # Aliases for plugin management
    if argv[0].lower() == "plugins":
        # 'menuscript plugins' -> list
        return _cmd_config_plugins(["list"])

    if argv[0].lower() == "plugin":
        # 'menuscript plugin on/off/reset <name?>'
        if len(argv) < 2:
            print("Usage: menuscript plugin [on|off|reset] <name?>")
            return 2
        sub = argv[1].lower()
        mapping = {"on": "enable", "off": "disable", "reset": "reset"}
        if sub not in mapping:
            print(RED + f"Unknown subcommand: {sub}" + RESET)
            if suggestion := _suggest(sub, list(mapping.keys())):
                print(CYAN + f"Did you mean: {suggestion} ?" + RESET)
            return 2
        return _cmd_config_plugins([mapping[sub]] + argv[2:])

    # Developer tools
    if argv[0].lower() == "dev":
        return _cmd_dev(argv[1:])

    # Jobs subcommand (background jobs)
    if argv[0].lower() == "jobs":
        return _cmd_jobs(argv[1:])

    # Unknown top-level command — suggest something useful
    print(RED + f"Unknown command: {argv[0]}" + RESET)
    if suggestion := _suggest(argv[0].lower(), ["config", "plugins", "plugin", "dev", "migrate", "--help", "--version"]):
        print(CYAN + f"Did you mean: {suggestion} ?" + RESET)
    return 2


if __name__ == "__main__":
    raise SystemExit(main())

