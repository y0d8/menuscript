#!/usr/bin/env python3
from pathlib import Path
from .utils import HISTORY_FILE, ensure_dirs, read_json, write_json, timestamp_str
import json, csv

# Export directory for JSON/CSV exports
EXPORT_DIR = Path.home() / ".menuscript" / "exports"
EXPORT_DIR.mkdir(parents=True, exist_ok=True)

def load_history():
    ensure_dirs()
    return read_json(HISTORY_FILE)

def add_history_entry(target, args, label, logpath, xmlpath=None, tool="nmap", summary=None):
    """
    Add an entry to the history.
    - target: target string (IP/CIDR/hostname)
    - args: list of args used for the tool
    - label: optional user label
    - logpath: path to the scan log file
    - xmlpath: (optional) path to xml output (for nmap)
    - tool: tool name string, e.g. "nmap", "gobuster"
    - summary: optional dict with structured summary (hosts, per_host, etc.)
    """
    ensure_dirs()
    h = load_history()
    entry = {
        "ts": timestamp_str(),
        "tool": tool,
        "target": target,
        "args": args,
        "label": label,
        "log": str(logpath),
        "xml": str(xmlpath) if xmlpath else None,
        "summary": summary if isinstance(summary, dict) else None
    }
    h.insert(0, entry)
    write_json(HISTORY_FILE, h[:200])
    return entry

def _safe_filename_component(s):
    s = str(s or "")
    # allow alnum, dot, dash, underscore; replace others with underscore
    return "".join(c if (c.isalnum() or c in ('.','-','_')) else '_' for c in s)

def _make_export_name(entry, ext):
    ts = entry.get("ts") or timestamp_str()
    tool = _safe_filename_component(entry.get("tool") or "tool")
    target = _safe_filename_component(entry.get("target") or "target")
    label = _safe_filename_component(entry.get("label") or "")
    base = f"{ts}_{tool}_{target}"
    if label:
        base += f"_{label}"
    return EXPORT_DIR / (base + "." + ext)

def export_entry_json(entry):
    """
    Exports the raw history entry to JSON.
    Returns the Path object of the exported file.
    """
    path = _make_export_name(entry, "json")
    with open(path, "w", encoding="utf-8") as f:
        json.dump(entry, f, indent=2)
    return path

def export_entry_csv(entry):
    """
    Exports a flattened CSV representing per-host rows (if available).
    If no per-host data, write a summary row.
    Returns the Path object of the exported file.
    """
    path = _make_export_name(entry, "csv")
    per_host = []
    summary = entry.get("summary") or {}
    # try common shapes: summary.per_host or summary['per_host']
    if isinstance(summary, dict):
        per_host = summary.get("per_host") or []
    # If per_host is empty, attempt to derive minimal info from summary
    if not per_host:
        # fallback single row giving summary metrics
        per_host = [{"addr": "", "up": None, "open": summary.get("open_ports", 0)}]

    # Write CSV file
    with open(path, "w", newline='', encoding="utf-8") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(["timestamp","tool","target","label","host","up","open_ports","log","xml"])
        for h in per_host:
            writer.writerow([
                entry.get("ts",""),
                entry.get("tool",""),
                entry.get("target",""),
                entry.get("label",""),
                h.get("addr", ""),
                bool(h.get("up")) if h.get("up") is not None else "",
                h.get("open", 0),
                entry.get("log",""),
                entry.get("xml","")
            ])
    return path
